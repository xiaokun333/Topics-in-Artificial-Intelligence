from BaseAI import BaseAIimport randomimport sysimport timeclass IntelligentAgent(BaseAI):        def getMove(self, state):        #print(0)        start_time = time.process_time()        move = self.decision(state, start_time)        return move[0]        def decision(self, state, start_time):        move = self.maximize(state, 0, -sys.maxsize, sys.maxsize, start_time)        return move        def minimize(self, state, depth, a, b, start_time):        """        computer plays        """        #print(1)        avail_cells = state.getAvailableCells()                # terminal test        time_diff = time.process_time() - start_time        #print(time_diff)        if depth >= 4 or len(avail_cells) == 0 or time_diff >= 0.1:            return (None, self.utility(state))                min_children = (None, sys.maxsize)                for cell in avail_cells:            # add a 2 tile            new_state_2 = state.clone()            new_state_2.insertTile(cell, 2) # add a 2 tile in available cell            t2 = self.maximize(new_state_2, depth + 1, a, b, start_time)            u2 = 0.9 * t2[1]                         # add a 4 tile            new_state_4 = state.clone()            new_state_4.insertTile(cell, 4) # add a 2 tile in available cell            t4 = self.maximize(new_state_4, depth + 1, a, b, start_time)            u4 = 0.1 * t4[1]                         util_weighted = u2 + u4            if util_weighted < min_children[1]:                min_children = (None, util_weighted)                        # alpha beta pruning            if min_children[1] <= a:                break            # update beta            if b > min_children[1]:                b = min_children[1]        return min_children        def maximize(self, state, depth, a, b, start_time):        """        player plays        """        #print(2)        avail_moves = state.getAvailableMoves()        time_diff = time.process_time() - start_time        #print(time_diff)        if depth >= 4 or len(avail_moves) == 0 or time_diff >= 0.1:            return (None, self.utility(state))        max_children = (None, -sys.maxsize)                for move in avail_moves:            new_tuple = self.minimize(move[1], depth + 1, a, b, start_time)            if new_tuple[1] > max_children[1]:                max_children = (move[0], new_tuple[1])                                return max_children       def utility(self, state):        sum_tile = self.sum_cells(state)        #         max_grad, diff = self.weighted_matrix(state)        mono = self.monotonicity(state)        max_tile = state.getMaxTile()        # return max_grad * (self.monotonicity(state) + 0.5 * sum_tile * len(state.getAvailableMoves()) + 2 * sum_tile * len(state.getAvailableCells()))        return max_grad * len(state.getAvailableCells()) * len(state.getAvailableMoves()) - diff * max_tile * sum_tile + mono        def sum_cells(self, state):        count = 0        for row in range(4):            for col in range(4):                count += state.map[row][col]        return count                        def monotonicity(self, state):        cur = 0        for row in range(4):            for col in range(3):                if state.map[row][col] >= state.map[row][col + 1]:                    # cur += state.map[row][col + 1]                    cur += 1        for col in range(4):            for row in range(3):                if state.map[row][col] >= state.map[row + 1][col]:                    #cur += state.map[row + 1][col]                    cur += 1        return cur            def weighted_matrix(self, state):        # TODO: try different matrices        matrix_1 = [[4**0, 4**1, 4**2, 4**3],                    [4**1, 4**2, 4**3, 4**4],                    [4**2, 4**3, 4**4, 4**5],                    [4**3, 4**4, 4**5, 4**6]                    ]                util_1 = 0                penalty = 0        for x in range(4):            for y in range(4):                cur_state = state.map[x][y]                util_1 += matrix_1[x][y] * cur_state                                penalty_x = 0                penalty_y = 0                if y < 3:                    penalty_y += abs(state.map[x][y] - state.map[x][y+1])                                    if x < 3:                    penalty_x += abs(state.map[x][y] - state.map[x+1][y])                                penalty += min(penalty_y, penalty_x)                        max_gradient = util_1        return max_gradient, penalty                                            